​有點偷吃步用套件直接.sort ＠＠
有看到一篇不錯的解法，如下：
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        for i in range(1, m + n + 1):
            if n == 0:
                break
            elif m == 0:
                nums1[-i] = nums2[n - 1]
                n -= 1
                continue
            
            if nums1[m - 1] < nums2[n - 1]:
                nums1[-i] = nums2[n - 1]
                n -= 1
            else:
                nums1[-i] = nums1[m - 1]
                m -= 1
```
--------------
這段代碼是一個Python類Solution的方法merge，用於合併兩個已排序陣列。讓我逐步解釋代碼的功能：

def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:：

這是一個方法定義，接受四個參數：
nums1：第一個已排序陣列。
m：nums1陣列中有效元素的數量。
nums2：第二個已排序陣列。
n：nums2陣列中元素的數量。
返回類型爲None，因爲該方法會直接修改nums1陣列。
for i in range(1, m + n + 1):：

這是一個循環，從1到m + n（包括m + n）遍歷。
循環控制變數i代表要填充的位置。
if n == 0: break：

如果nums2陣列中的元素已經全部被合併完畢，則結束循環。
elif m == 0:：

如果nums1陣列中的元素已經全部被合併完畢，將nums2陣列中剩餘的元素依次放入nums1陣列的末尾，並結束循環。
if nums1[m - 1] < nums2[n - 1]:：

如果nums1陣列的最後一個元素小於nums2陣列的最後一個元素，則將nums2陣列的最後一個元素放入nums1陣列的末尾。
else:：

如果nums1陣列的最後一個元素大於或等於nums2陣列的最後一個元素，則將nums1陣列的最後一個元素放入nums1陣列的末尾。
在循環結束後，nums1陣列將包含合併後的兩個已排序陣列的所有元素，且仍保持有序。
---------------
舉例：
nums1 = [1, 3, 5, 0, 0, 0]
m = 3
nums2 = [2, 4, 6]
n = 3
現在我們要合併這兩個陣列，首先看一下初始化後的nums1和nums2的情況：

nums1初始化爲[1, 3, 5, 0, 0, 0]，其中前三個元素是有效元素，後三個是空餘的位置。
nums2初始化爲[2, 4, 6]。
我們將按照從後往前的順序，依次比較nums1和nums2中的元素，並將較大的元素依次放入nums1陣列的末尾。

第一次比較：

nums1的最後一個有效元素是5，nums2的最後一個元素是6，5 < 6，所以將6放入nums1的最後位置，nums1變爲[1, 3, 5, 0, 0, 6]。
n減1，nums2變爲[2, 4]。
第二次比較：

nums1的倒數第二個有效元素是5，nums2的最後一個元素是4，5 > 4，所以將5放入nums1的倒數第二個位置，nums1變爲[1, 3, 5, 0, 5, 6]。
m減1，nums1變爲[1, 3, 5, 0, 5, 6]。
第三次比較：

nums1的倒數第三個有效元素是3，nums2的最後一個元素是2，3 > 2，所以將3放入nums1的倒數第三個位置，nums1變爲[1, 3, 3, 0, 5, 6]。
m減1，nums1變爲[1, 3, 3, 0, 5, 6]。
第四次比較：

nums1的倒數第四個位置已經沒有有效元素，因此直接將nums2的最後一個元素2放入nums1的倒數第四個位置，nums1變爲[1, 2, 3, 0, 5, 6]。
n減1，nums2變爲[2]。
第五次比較：

nums1的倒數第五個位置已經沒有有效元素，因此直接將nums2的最後一個元素2放入nums1的倒數第五個位置，nums1變爲[1, 2, 3, 0, 5, 6]。
n減1，nums2變爲[]。
第六次比較：

nums1的倒數第六個位置已經沒有有效元素，因此直接結束比較。
最終合併後的nums1陣列爲[1, 2, 3, 4, 5, 6]。

這個演算法的核心思想是利用已經排序的陣列的特性，通過從後往前逐個比較兩個陣列的元素，並將較大的元素依次放入合併後的陣列中。
